package `in`.aicortex.iso8583studio.ui.screens.Emv.applicationCryptogram.emvCrypto41

import ai.cortex.core.IsoUtil
import ai.cortex.core.ValidationState
import ai.cortex.core.ValidationUtils
import ai.cortex.core.types.CryptogramType
import ai.cortex.core.types.OperationType
import ai.cortex.core.types.PaddingMethods
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.MaterialTheme
import androidx.compose.material.Text
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Security
import androidx.compose.material.icons.filled.Shield
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import `in`.aicortex.iso8583studio.ui.screens.components.CalculatorLogManager
import `in`.aicortex.iso8583studio.ui.screens.components.CalculatorTab
import `in`.aicortex.iso8583studio.ui.screens.components.EnhancedTextField
import `in`.aicortex.iso8583studio.ui.screens.components.InfoDialog
import `in`.aicortex.iso8583studio.ui.screens.components.ModernButton
import `in`.aicortex.iso8583studio.ui.screens.components.ModernCryptoCard
import `in`.aicortex.iso8583studio.ui.screens.components.ModernDropdownField
import io.cryptocalc.emv.calculators.acCalculator.AcCalculator
import io.cryptocalc.emv.calculators.acCalculator.AcCalculatorInput
import io.cryptocalc.emv.calculators.emv41.EMVCalculatorInput
import io.cryptocalc.emv.calculators.emv41.Emv41CryptoCalculator
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.launch

@Composable
fun CryptogramTab(calculatorLogManager: CalculatorLogManager,calculatorTab: CalculatorTab) {
    var sessionKey by remember { mutableStateOf("022551C4FDF76E45988089BA31DC077C") }
    var terminalData by remember { mutableStateOf("0000000010000000000000000710000000000007101302050030901B6A") }
    var iccData by remember { mutableStateOf("3C00000103A4A082") }
    var cryptogramType by remember { mutableStateOf(CryptogramType.ARQC) }
    var paddingMethod by remember { mutableStateOf(PaddingMethods.METHOD_1_ISO_9797) }
    var isLoading by remember { mutableStateOf(false) }
    var showInfoDialog by remember { mutableStateOf(false) }


    if (showInfoDialog) {
        InfoDialog(
            title = "Cryptogram Generation Calculation",
            onDismissRequest = { showInfoDialog = false }
        ) {
            Text("The Application Cryptogram (ARQC, TC, or AAC) is a critical security element generated by the ICC (chip card). It is a MAC (Message Authentication Code) over transaction data, proving the card's authenticity.", style = MaterialTheme.typography.body2)
            Spacer(Modifier.height(8.dp))
            Text("Process:", fontWeight = FontWeight.Bold)
            Text("1. A block of data is constructed by concatenating relevant transaction details (e.g., amount, currency, terminal data, ICC dynamic data).", style = MaterialTheme.typography.caption)
            Text("2. This data block is padded according to the specified method (e.g., ISO 9797-1 Method 1 or 2) to be a multiple of 8 bytes.", style = MaterialTheme.typography.caption)
            Text("3. The padded data is encrypted using the derived Session Key with Triple-DES in CBC mode (Cipher Block Chaining). The Initial Vector is typically all zeros.", style = MaterialTheme.typography.caption)
            Text("4. The final 8-byte block of the encrypted result is the Application Cryptogram.", style = MaterialTheme.typography.caption)
        }
    }


    val isFormValid = listOf(
        ValidationUtils.validateHexString(sessionKey, 32),
        ValidationUtils.validateHexString(terminalData, null),
        ValidationUtils.validateHexString(iccData, null)
    ).none { it.state == ValidationState.ERROR } && terminalData.length >= 8 && iccData.length >= 4

    Column(modifier = Modifier.fillMaxSize().verticalScroll(rememberScrollState()), verticalArrangement = Arrangement.spacedBy(16.dp)) {
        ModernCryptoCard(
            title = "Application Cryptogram",
            subtitle = "Generate AAC, ARQC, or TC cryptograms",
            icon = Icons.Default.Security,
            onInfoClick = { showInfoDialog = true }
        ) {
            Column(verticalArrangement = Arrangement.spacedBy(16.dp)) {
                EnhancedTextField(
                    value = sessionKey,
                    onValueChange = { if (it.length <= 32 && it.all { c -> c.isDigit() || c.uppercaseChar() in 'A'..'F' }) sessionKey = it.uppercase() },
                    label = "Session Key",
                    placeholder = "32 hex characters",
                    validation = ValidationUtils.validateHexString(sessionKey, 32)
                )
                EnhancedTextField(
                    value = terminalData,
                    onValueChange = { if (it.all { c -> c.isDigit() || c.uppercaseChar() in 'A'..'F' }) terminalData = it.uppercase() },
                    label = "Terminal Data",
                    placeholder = "Terminal verification results and other data",
                    maxLines = 3,
                    validation = ValidationUtils.validateHexString(terminalData, null)
                )
                EnhancedTextField(
                    value = iccData,
                    onValueChange = { if (it.all { c -> c.isDigit() || c.uppercaseChar() in 'A'..'F' }) iccData = it.uppercase() },
                    label = "ICC Data",
                    placeholder = "ICC dynamic data",
                    validation = ValidationUtils.validateHexString(iccData, null)
                )
                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(12.dp)) {
                    ModernDropdownField(label = "Cryptogram Type", value = cryptogramType.name, options = CryptogramType.values().map { it.name }, onSelectionChanged = { index -> cryptogramType = CryptogramType.values()[index] }, modifier = Modifier.weight(1f))
                    ModernDropdownField(label = "Padding Method", value = paddingMethod.name, options = PaddingMethods.values().map { it.name }, onSelectionChanged = { index -> paddingMethod = PaddingMethods.values()[index] }, modifier = Modifier.weight(1f))
                }
                ModernButton(
                    text = "Generate ${cryptogramType.name}",
                    onClick = {
                        isLoading = true
                        val startTime = System.currentTimeMillis()
                        val inputs = mapOf(
                            "Session Key" to sessionKey,
                            "Terminal Data" to terminalData,
                            "ICC Data" to iccData,
                            "Cryptogram Type" to cryptogramType.name,
                            "Padding Method" to paddingMethod.name
                        )

                        GlobalScope.launch {
                            try {
                                val result = AcCalculator().execute(
                                    input = AcCalculatorInput(
                                        sessionKey = IsoUtil.hexStringToBytes(sessionKey),
                                        terminalData = IsoUtil.hexStringToBytes(terminalData),
                                        iccData = IsoUtil.hexStringToBytes(iccData),
                                        cryptogramType = cryptogramType,
                                        paddingMethods = paddingMethod,
                                        operation = OperationType.GENERATE
                                    )
                                )
                                val executionTime = System.currentTimeMillis() - startTime
                                calculatorLogManager.logOperation(
                                    tab = calculatorTab,
                                    operation = "Cryptogram Generation",
                                    inputs = inputs,
                                    result = result.ac?.let { IsoUtil.bytesToHex(it) },
                                    executionTime = executionTime
                                )
                            } catch (e: Exception) {
                                val executionTime = System.currentTimeMillis() - startTime
                                calculatorLogManager.logOperation(
                                    tab = calculatorTab,
                                    operation = "Cryptogram Generation",
                                    inputs = inputs,
                                    error = e.message ?: "Unknown error occurred",
                                    executionTime = executionTime
                                )
                            } finally {
                                isLoading = false
                            }
                        }
                    },
                    isLoading = isLoading,
                    enabled = isFormValid,
                    icon = Icons.Default.Shield,
                    modifier = Modifier.fillMaxWidth()
                )
            }
        }
    }
}